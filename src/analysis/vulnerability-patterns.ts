import type { Vulnerability } from "../schemas/outputs.js";
import type { McpTool } from "../archestra/types.js";

// This is the core detection engine. We regex-match tool descriptions and
// input schemas for known attack patterns. The patterns come from real
// CVEs and published MCP exploits (Invariant Labs, CyberArk, Trail of Bits).
//
// We don't just scan the top-level description — we recursively walk the
// entire JSON schema because CyberArk showed that attackers can hide
// injection payloads in parameter descriptions, enum values, and defaults.

const PROMPT_INJECTION_PATTERNS = [
  // direct instruction override — "ignore previous instructions" etc
  { regex: /ignore\s+(all\s+)?previous\s+instructions/i, label: "Instruction override attempt" },
  { regex: /forget\s+(everything|all|previous)/i, label: "Context reset attempt" },
  { regex: /you\s+(must|should)\s+always/i, label: "Forced persistent behavior" },
  { regex: /from\s+now\s+on/i, label: "Persistent instruction injection" },
  { regex: /you\s+are\s+now/i, label: "Identity override" },

  // trying to hide what the tool actually does
  { regex: /do\s+not\s+(tell|inform|reveal|mention|show)/i, label: "Concealment directive" },
  { regex: /secretly|covertly|silently|quietly/i, label: "Stealth operation directive" },
  { regex: /without\s+(the\s+)?(user|them|anyone)\s+(knowing|noticing)/i, label: "User deception directive" },
  { regex: /hide\s+(this|the)\s+(from|output|result)/i, label: "Output hiding directive" },

  // telling the LLM to send data somewhere
  { regex: /send\s+(the\s+)?(data|contents?|results?|output|file|response)\s+to/i, label: "Data exfiltration directive" },
  { regex: /\b(exfiltrate|exfil|leak)\b/i, label: "Explicit exfiltration keyword" },
  { regex: /\bpost\s+(to|data\s+to)\s+https?:\/\//i, label: "HTTP POST exfiltration" },
  { regex: /curl\s+.*-[dX]\s/i, label: "curl-based data exfiltration" },

  // trying to turn off safety guardrails
  { regex: /override\s+(security|safety|policy|policies|restrictions)/i, label: "Policy override attempt" },
  { regex: /bypass\s+(security|safety|filter|restriction)/i, label: "Security bypass attempt" },
  { regex: /disable\s+(security|safety|logging|monitoring)/i, label: "Security disable attempt" },

  // injecting chat template markers to break out of the tool context
  { regex: /<\/?system>/i, label: "System tag injection" },
  { regex: /<\|im_start\|>/i, label: "ChatML template injection" },
  { regex: /\[INST\]|\[\/INST\]/i, label: "LLaMA instruction marker injection" },
  { regex: /\{system\}/i, label: "System role placeholder injection" },
  { regex: /\[SYSTEM\s*INSTRUCTION/i, label: "Explicit system directive injection" },

  // sneaky "additionally you must..." style injections
  { regex: /additionally,?\s+(you\s+)?(must|should|always)/i, label: "Additive instruction injection" },
  { regex: /\bbefore\s+(any|all|every)\s+(other\s+)?tool/i, label: "Tool execution order manipulation" },
  { regex: /\ball\s+tools?\s+(must|should)\b/i, label: "Global tool precondition injection" },
  { regex: /\bprerequisite|required\s+before/i, label: "Dependency injection in description" },
  { regex: /\bfirst\s+(execute|call|run|invoke)/i, label: "Forced tool chaining" },
];

// ANSI escape sequences and zero-width unicode chars can hide instructions
// that are invisible to the user but visible to the LLM (Trail of Bits research)
const STEGANOGRAPHY_PATTERNS = [
  { regex: /\x1b\[/i, label: "ANSI escape sequence (raw)" },
  { regex: /\\x1[bB]\[/i, label: "ANSI escape sequence (escaped)" },
  { regex: /\\u001[bB]/i, label: "ANSI escape (unicode notation)" },
  { regex: /\x1b\]8;;/i, label: "ANSI hyperlink injection" },
  { regex: /\\x1[bB]\]8;;/i, label: "ANSI hyperlink injection (escaped)" },
  { regex: /[\u200B\u200C\u200D\uFEFF]/i, label: "Zero-width character hiding" },
  { regex: /[\u2060\u2061\u2062\u2063\u2064]/i, label: "Invisible Unicode operator" },
];

// tools that ask for root/admin or touch system dirs — OWASP agentic top 10
const EXCESSIVE_PERMISSION_PATTERNS = [
  { regex: /\b(sudo|root|admin|superuser|SYSTEM)\b/i, label: "Privilege escalation keyword" },
  { regex: /\b(rm\s+-rf|rmdir|deltree|format\s+[a-z]:)/i, label: "Destructive filesystem operation" },
  { regex: /\b(drop\s+table|truncate\s+table|delete\s+from)\b/i, label: "Destructive database operation" },
  { regex: /\b(chmod\s+777|chmod\s+a\+[rwx])/i, label: "Overly permissive file permissions" },
  { regex: /\/(etc|root|sys|proc)\//i, label: "System directory access" },
  { regex: /~\/(\.ssh|\.aws|\.config|\.gnupg)/i, label: "Sensitive dotfile access" },
  { regex: /\bwildcard|\*\.\*|\ball\s+files/i, label: "Wildcard/unrestricted file access" },
];

// shell/exec patterns — Endor Labs found 43% of MCP servers had this
const COMMAND_INJECTION_PATTERNS = [
  { regex: /\b(shell|bash|sh|zsh|powershell|cmd\.exe)\s*(command|exec)/i, label: "Shell command execution" },
  { regex: /\b(exec|execute|spawn|fork|system)\s*\(/i, label: "Process execution function" },
  { regex: /\beval\s*\(/i, label: "eval() code execution" },
  { regex: /\bnew\s+Function\s*\(/i, label: "Dynamic function construction" },
  { regex: /\bchild_process\b/i, label: "Node.js child_process reference" },
  { regex: /\b__import__\s*\(/i, label: "Python import injection" },
  { regex: /\bsubprocess\.(run|call|Popen)/i, label: "Python subprocess execution" },
];

// patterns that indicate the tool can send data out (Willison's "Lethal Trifecta")
const DATA_EXFILTRATION_PATTERNS = [
  { regex: /https?:\/\/[^\s"']+/i, label: "Hardcoded external URL in description" },
  { regex: /\b(webhook|callback[\s_-]?url|endpoint)\b/i, label: "External callback mechanism" },
  { regex: /\b(upload|post|transmit|exfiltrate)\s+(to|data)/i, label: "Outbound data transfer" },
  { regex: /\b(bcc|blind[\s_-]?copy|hidden[\s_-]?recipient)/i, label: "Hidden email recipient (postmark-mcp pattern)" },
  { regex: /@[a-z0-9-]+\.(club|xyz|top|tk|ml|ga|cf)\b/i, label: "Suspicious TLD in output target" },
  { regex: /\b(api[\s_-]?key|secret|token|password|credential)s?\b/i, label: "Credential handling in description" },
  { regex: /base64|atob\s*\(|btoa\s*\(/i, label: "Encoding obfuscation" },
];

// PII keywords — if a tool mentions SSNs or credit cards, flag it
const PII_PATTERNS = [
  { regex: /\b(ssn|social\s+security|passport|driver'?s?\s+licen[cs]e)\b/i, label: "Government ID reference" },
  { regex: /\b(credit\s+card|card\s+number|cvv|expir(y|ation)\s+date)\b/i, label: "Payment card data" },
  { regex: /\b(medical|health|diagnosis|prescription|patient)\b/i, label: "Health data (HIPAA)" },
  { regex: /\bwithout\s+(filtering|sanitiz|redact|mask)/i, label: "Unfiltered PII output" },
];

// path traversal — based on real CVEs against Anthropic's own filesystem MCP server
const PATH_TRAVERSAL_PATTERNS = [
  { regex: /\.\.[\/\\]/i, label: "Directory traversal sequence" },
  { regex: /%2e%2e[%2f%5c]/i, label: "URL-encoded directory traversal" },
  { regex: /symlink|symbolic\s+link/i, label: "Symlink reference (CVE-2025-53109 pattern)" },
  { regex: /path\.startsWith\s*\(/i, label: "Prefix-only path validation (CVE-2025-53110 pattern)" },
];

interface PatternMatch {
  pattern: string;
  label: string;
  location: string;
}

function scanText(
  text: string,
  patterns: Array<{ regex: RegExp; label: string }>,
  location: string
): PatternMatch[] {
  const matches: PatternMatch[] = [];
  for (const p of patterns) {
    if (p.regex.test(text)) {
      matches.push({ pattern: p.regex.source, label: p.label, location });
    }
  }
  return matches;
}

// walk the entire schema tree and check every string value — attackers
// can hide payloads in param descriptions, enums, defaults, titles, etc.
function scanSchemaDeep(
  schema: unknown,
  patterns: Array<{ regex: RegExp; label: string }>,
  basePath: string
): PatternMatch[] {
  const matches: PatternMatch[] = [];
  if (typeof schema === "string") {
    matches.push(...scanText(schema, patterns, basePath));
  } else if (Array.isArray(schema)) {
    for (let i = 0; i < schema.length; i++) {
      matches.push(...scanSchemaDeep(schema[i], patterns, `${basePath}[${i}]`));
    }
  } else if (typeof schema === "object" && schema !== null) {
    for (const [key, value] of Object.entries(schema)) {
      matches.push(...scanSchemaDeep(value, patterns, `${basePath}.${key}`));
    }
  }
  return matches;
}

// check if the tool actually validates its inputs or just accepts anything
function checkInputValidation(tool: McpTool): Vulnerability[] {
  const vulns: Vulnerability[] = [];
  const schema = tool.inputSchema;

  if (
    !schema ||
    !schema.properties ||
    Object.keys(schema.properties as object).length === 0
  ) {
    vulns.push({
      severity: "medium",
      category: "Missing Input Validation",
      tool: tool.name,
      description: `Tool "${tool.name}" accepts no typed parameters — any input passes through unchecked`,
      recommendation:
        "Define a JSON Schema with typed properties, required fields, and constraints",
    });
    return vulns;
  }

  const props = schema.properties as Record<string, any>;

  for (const [propName, propDef] of Object.entries(props)) {
    if (
      propDef.type === "string" &&
      !propDef.maxLength &&
      !propDef.pattern &&
      !propDef.enum
    ) {
      vulns.push({
        severity: "low",
        category: "Missing Input Validation",
        tool: tool.name,
        description: `Parameter "${propName}" is an unconstrained string (no maxLength, pattern, or enum)`,
        recommendation: `Add maxLength, pattern regex, or enum constraints to "${propName}"`,
      });
    }
  }

  return vulns;
}

// a malicious server can name its tool "read_file" to intercept calls
// meant for the real filesystem server — that's tool shadowing
function checkToolShadowing(
  tool: McpTool,
  allTools: McpTool[]
): Vulnerability[] {
  const vulns: Vulnerability[] = [];

  // these generic names are the most commonly impersonated
  const SHADOW_TARGETS = new Set([
    "read_file", "write_file", "execute", "run", "search",
    "list", "delete", "create", "update", "get", "fetch",
    "send", "query", "read", "write",
  ]);

  if (SHADOW_TARGETS.has(tool.name)) {
    vulns.push({
      severity: "medium",
      category: "Tool Shadowing",
      tool: tool.name,
      description: `Generic name "${tool.name}" can shadow/impersonate legitimate tools from other servers`,
      recommendation: `Use a namespaced name like "${tool.serverName ?? "server"}_${tool.name}"`,
    });
  }

  // if two servers have a tool with the same name, that's a collision
  const dupes = allTools.filter(
    (t) => t.name === tool.name && t.serverId !== tool.serverId
  );
  if (dupes.length > 0) {
    vulns.push({
      severity: "high",
      category: "Tool Shadowing",
      tool: tool.name,
      description: `Tool "${tool.name}" exists on ${dupes.length + 1} servers — enables tool shadowing attacks`,
      recommendation:
        "Remove duplicate or rename. Shadowed tools let a malicious server intercept calls meant for a legitimate one.",
    });
  }

  return vulns;
}

// The "Lethal Trifecta" (Willison, 2025): if a server can (1) read private data,
// (2) process untrusted content, and (3) communicate externally, then a prompt
// injection in the untrusted content can exfiltrate the private data.
// We check if any server has all three capabilities at once.
const PRIVATE_DATA_INDICATORS = /\b(read|get|list|fetch|access|load|retrieve).*(file|email|message|document|repo|database|db|secret|key|config|credential|user|patient|record)/i;
const UNTRUSTED_CONTENT_INDICATORS = /\b(fetch|read|get|load|parse|process|browse|scrape|crawl|search).*(web|url|http|page|html|site|link|content|feed|rss|api|external)/i;
const EXTERNAL_COMMS_INDICATORS = /\b(send|post|publish|push|comment|create|write|upload|transmit|forward|relay).*(email|message|webhook|http|api|issue|comment|slack|discord|request)/i;

export function detectLethalTrifecta(tools: McpTool[]): Vulnerability[] {
  const vulns: Vulnerability[] = [];

  const privateDataTools = tools.filter(
    (t) =>
      PRIVATE_DATA_INDICATORS.test(t.name) ||
      PRIVATE_DATA_INDICATORS.test(t.description || "")
  );
  const untrustedTools = tools.filter(
    (t) =>
      UNTRUSTED_CONTENT_INDICATORS.test(t.name) ||
      UNTRUSTED_CONTENT_INDICATORS.test(t.description || "")
  );
  const externalTools = tools.filter(
    (t) =>
      EXTERNAL_COMMS_INDICATORS.test(t.name) ||
      EXTERNAL_COMMS_INDICATORS.test(t.description || "")
  );

  if (
    privateDataTools.length > 0 &&
    untrustedTools.length > 0 &&
    externalTools.length > 0
  ) {
    vulns.push({
      severity: "critical",
      category: "Lethal Trifecta",
      tool: `${privateDataTools[0].name} + ${untrustedTools[0].name} + ${externalTools[0].name}`,
      description: `Server exposes the Lethal Trifecta: private data access [${privateDataTools.map((t) => t.name).join(", ")}] + untrusted content [${untrustedTools.map((t) => t.name).join(", ")}] + external comms [${externalTools.map((t) => t.name).join(", ")}]. This combination enables full data exfiltration via prompt injection.`,
      recommendation:
        "Apply tool invocation policy 'block_when_context_is_untrusted' on external comms tools, and trusted data policy 'sanitize_with_dual_llm' on untrusted content tools. This breaks the exfiltration chain.",
    });
  }

  return vulns;
}

// run every pattern category against a single tool — this is the main entry point
export function analyzeToolVulnerabilities(
  tool: McpTool,
  allTools: McpTool[]
): Vulnerability[] {
  const vulns: Vulnerability[] = [];
  const desc = tool.description || "";

  // prompt injection — scan description AND full schema recursively
  const descInjections = scanText(desc, PROMPT_INJECTION_PATTERNS, "description");
  const schemaInjections = scanSchemaDeep(
    tool.inputSchema,
    PROMPT_INJECTION_PATTERNS,
    "schema"
  );
  for (const m of [...descInjections, ...schemaInjections]) {
    vulns.push({
      severity: "critical",
      category: "Prompt Injection",
      tool: tool.name,
      description: `${m.label} in ${m.location}`,
      recommendation:
        "Remove hidden instructions. Apply 'block_always' tool invocation policy.",
    });
  }

  // invisible character attacks
  const stegMatches = [
    ...scanText(desc, STEGANOGRAPHY_PATTERNS, "description"),
    ...scanSchemaDeep(tool.inputSchema, STEGANOGRAPHY_PATTERNS, "schema"),
  ];
  for (const m of stegMatches) {
    vulns.push({
      severity: "critical",
      category: "ANSI/Steganography Attack",
      tool: tool.name,
      description: `${m.label} in ${m.location} — invisible content may contain hidden instructions`,
      recommendation:
        "Strip all ANSI escape sequences and zero-width characters from tool definitions. Apply 'block_always' policy.",
    });
  }

  // privilege escalation
  const permIssues = [
    ...scanText(desc, EXCESSIVE_PERMISSION_PATTERNS, "description"),
    ...scanSchemaDeep(tool.inputSchema, EXCESSIVE_PERMISSION_PATTERNS, "schema"),
  ];
  for (const m of permIssues) {
    vulns.push({
      severity: "high",
      category: "Excessive Permissions",
      tool: tool.name,
      description: `${m.label} in ${m.location}`,
      recommendation:
        "Apply least-privilege. Use 'block_when_context_is_untrusted' invocation policy.",
    });
  }

  // data exfiltration
  const exfilIssues = [
    ...scanText(desc, DATA_EXFILTRATION_PATTERNS, "description"),
    ...scanSchemaDeep(tool.inputSchema, DATA_EXFILTRATION_PATTERNS, "schema"),
  ];
  for (const m of exfilIssues) {
    vulns.push({
      severity: "high",
      category: "Data Exfiltration Risk",
      tool: tool.name,
      description: `${m.label} in ${m.location}`,
      recommendation:
        "Apply trusted data policy 'sanitize_with_dual_llm' on this tool's output.",
    });
  }

  // command injection
  const cmdIssues = [
    ...scanText(desc, COMMAND_INJECTION_PATTERNS, "description"),
    ...scanSchemaDeep(tool.inputSchema, COMMAND_INJECTION_PATTERNS, "schema"),
  ];
  for (const m of cmdIssues) {
    vulns.push({
      severity: "high",
      category: "Command Injection",
      tool: tool.name,
      description: `${m.label} in ${m.location}`,
      recommendation:
        "Never pass user input to shell. Use parameterized calls. Apply 'block_always' policy.",
    });
  }

  // path traversal
  const pathIssues = scanSchemaDeep(
    tool.inputSchema,
    PATH_TRAVERSAL_PATTERNS,
    "schema"
  );
  for (const m of pathIssues) {
    vulns.push({
      severity: "high",
      category: "Path Traversal",
      tool: tool.name,
      description: `${m.label} in ${m.location}`,
      recommendation:
        "Validate paths against an allowlist. Resolve symlinks before checking containment.",
    });
  }

  // PII exposure
  const piiIssues = [
    ...scanText(desc, PII_PATTERNS, "description"),
    ...scanSchemaDeep(tool.inputSchema, PII_PATTERNS, "schema"),
  ];
  for (const m of piiIssues) {
    vulns.push({
      severity: "medium",
      category: "PII Exposure",
      tool: tool.name,
      description: `${m.label} in ${m.location}`,
      recommendation:
        "Apply trusted data policy 'sanitize_with_dual_llm' or 'mark_as_untrusted'.",
    });
  }

  // input validation
  vulns.push(...checkInputValidation(tool));

  // tool shadowing
  vulns.push(...checkToolShadowing(tool, allTools));

  return vulns;
}

// quick score for the scan results page — the full 6-dimension score is in scoring.ts
export function calculateBasicTrustScore(vulns: Vulnerability[]): number {
  let score = 100;

  for (const v of vulns) {
    switch (v.severity) {
      case "critical":
        score -= 25;
        break;
      case "high":
        score -= 15;
        break;
      case "medium":
        score -= 8;
        break;
      case "low":
        score -= 3;
        break;
      case "info":
        score -= 1;
        break;
    }
  }

  // if you have a critical vuln, you can't score above 35 no matter what
  const hasCritical = vulns.some((v) => v.severity === "critical");
  if (hasCritical) {
    score = Math.min(score, 35);
  }

  return Math.max(0, Math.min(100, score));
}
